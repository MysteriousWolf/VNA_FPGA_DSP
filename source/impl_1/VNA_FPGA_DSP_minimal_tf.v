

// TOOL:     vlog2tf
// DATE:     Tue Oct  8 14:04:33 2024
 
// TITLE:    Lattice Semiconductor Corporation
// MODULE:   dsp_core
// DESIGN:   dsp_core
// FILENAME: VNA_FPGA_DSP_tf.v
// PROJECT:  VNA_FPGA_DSP
// VERSION:  2.0
// This file is auto generated by Radiant


`timescale 1 ns / 1 ps

// Single Clock FIFO module
module meas_fifo_sc #(
    parameter FIFO_DEPTH = 4,
    parameter ADDR_WIDTH = $clog2(FIFO_DEPTH),
    parameter USE_OUTPUT_REG = 0
) (
    input wire clk_i,
    input wire rst_i,
    input wire wr_en_i,
    input wire rd_en_i,
    input wire [23:0] wr_data_i,
    output wire full_o,
    output wire empty_o,
    output reg [23:0] rd_data_o
);

    // Memory array
    reg [23:0] mem [0:FIFO_DEPTH-1];
    
    // Pointers and internal signals
    reg [ADDR_WIDTH:0] wr_ptr, rd_ptr;
    reg [23:0] rd_data_internal;
    reg rd_data_valid;
    
    // Write logic - on falling edge
    always @(negedge clk_i or posedge rst_i) begin
        if (rst_i) begin
            wr_ptr <= 0;
        end else if (wr_en_i && !full_o) begin
            mem[wr_ptr[ADDR_WIDTH-1:0]] <= wr_data_i;
            wr_ptr <= wr_ptr + 1;
        end
    end

    // Read data fetch on falling edge
    always @(negedge clk_i or posedge rst_i) begin
        if (rst_i) begin
            rd_data_internal <= 0;
            rd_data_valid <= 0;
        end else begin
            if (rd_en_i && !empty_o) begin
                rd_data_internal <= mem[rd_ptr[ADDR_WIDTH-1:0]];
                rd_data_valid <= 1;
            end else begin
                rd_data_valid <= 0;
            end
        end
    end

    // Read pointer update and output presentation
    generate
        if (USE_OUTPUT_REG) begin
            // Registered output - updates on rising edge
            always @(posedge clk_i or posedge rst_i) begin
                if (rst_i) begin
                    rd_ptr <= 0;
                    rd_data_o <= 0;
                end else begin
                    if (rd_data_valid) begin
                        rd_data_o <= rd_data_internal;
                        rd_ptr <= rd_ptr + 1;
                    end
                end
            end
        end else begin
            // Combinational output
            always @(negedge clk_i or posedge rst_i) begin
                if (rst_i) begin
                    rd_ptr <= 0;
                end else if (rd_en_i && !empty_o) begin
                    rd_ptr <= rd_ptr + 1;
                end
            end
            
            always @(*) begin
                rd_data_o = rd_data_internal;
            end
        end
    endgenerate
    
    // Status flags - simplified for single clock domain
    assign full_o = ((wr_ptr[ADDR_WIDTH-1:0] == rd_ptr[ADDR_WIDTH-1:0]) && 
                    (wr_ptr[ADDR_WIDTH] != rd_ptr[ADDR_WIDTH]));
    assign empty_o = (wr_ptr == rd_ptr);

endmodule

// FIFO Module with parameterized depth
module meas_fifo #(
    parameter FIFO_DEPTH = 4,
    parameter ADDR_WIDTH = $clog2(FIFO_DEPTH),
    parameter USE_OUTPUT_REG = 1  // Set to 1 to enable output registers
) (
    input wire wr_clk_i,
    input wire rd_clk_i,
    input wire rst_i,
    input wire rp_rst_i,
    input wire wr_en_i,
    input wire rd_en_i,
    input wire [23:0] wr_data_i,
    output wire full_o,
    output wire empty_o,
    output reg [23:0] rd_data_o
);

    // Memory array
    reg [23:0] mem [0:FIFO_DEPTH-1];
    
    // Pointers and internal signals
    reg [ADDR_WIDTH:0] wr_ptr, rd_ptr;
    reg [ADDR_WIDTH:0] wr_ptr_gray, rd_ptr_gray;
    reg [ADDR_WIDTH:0] wr_ptr_sync, rd_ptr_sync;
    
    // Internal signals for read control
    reg [23:0] rd_data_internal;
    reg rd_data_valid;
    
    // Gray code conversion function
    function [ADDR_WIDTH:0] bin2gray(input [ADDR_WIDTH:0] bin);
        bin2gray = (bin >> 1) ^ bin;
    endfunction
    
    // Write logic - on falling edge
    always @(negedge wr_clk_i or posedge rst_i) begin
        if (rst_i) begin
            wr_ptr <= 0;
            wr_ptr_gray <= 0;
        end else if (wr_en_i && !full_o) begin
            mem[wr_ptr[ADDR_WIDTH-1:0]] <= wr_data_i;
            wr_ptr <= wr_ptr + 1;
            wr_ptr_gray <= bin2gray(wr_ptr + 1);
        end
    end

    // Read data fetch on falling edge
    always @(negedge rd_clk_i or posedge rst_i) begin
        if (rst_i) begin
            rd_data_internal <= 0;
            rd_data_valid <= 0;
        end else begin
            if (rd_en_i && !empty_o) begin
                rd_data_internal <= mem[rd_ptr[ADDR_WIDTH-1:0]];
                rd_data_valid <= 1;
            end else begin
                rd_data_valid <= 0;
            end
        end
    end

    // Read pointer update and output presentation
    generate
        if (USE_OUTPUT_REG) begin
            // Registered output - updates on rising edge
            always @(posedge rd_clk_i or posedge rst_i) begin
                if (rst_i) begin
                    rd_ptr <= 0;
                    rd_ptr_gray <= 0;
                    rd_data_o <= 0;
                end else begin
                    if (rd_data_valid) begin
                        rd_data_o <= rd_data_internal;
                        rd_ptr <= rd_ptr + 1;
                        rd_ptr_gray <= bin2gray(rd_ptr + 1);
                    end
                end
            end
        end else begin
            // Combinational output
            always @(negedge rd_clk_i or posedge rst_i) begin
                if (rst_i) begin
                    rd_ptr <= 0;
                    rd_ptr_gray <= 0;
                end else if (rd_en_i && !empty_o) begin
                    rd_ptr <= rd_ptr + 1;
                    rd_ptr_gray <= bin2gray(rd_ptr + 1);
                end
            end
            
            always @(*) begin
                rd_data_o = rd_data_internal;
            end
        end
    endgenerate
    
    // Synchronization registers
    always @(posedge wr_clk_i or posedge rst_i) begin
        if (rst_i)
            rd_ptr_sync <= 0;
        else
            rd_ptr_sync <= rd_ptr_gray;
    end
    
    always @(posedge rd_clk_i or posedge rst_i) begin
        if (rst_i)
            wr_ptr_sync <= 0;
        else
            wr_ptr_sync <= wr_ptr_gray;
    end
    
    // Status flags
    assign full_o = (wr_ptr_gray == {~rd_ptr_sync[ADDR_WIDTH:ADDR_WIDTH-1], 
                                    rd_ptr_sync[ADDR_WIDTH-2:0]});
    assign empty_o = (rd_ptr_gray == wr_ptr_sync);

endmodule

// Define Module for Test Fixture
module dsp_core_tf();
	
	// Parameters
	parameter PRE_ST_DELAY = 10;
	parameter PLL_LOCK_DELAY = 10;
	parameter ADC_DELAY = 7.5; // Worst case from the datasheet
	parameter HS_PERIOD = 1000/250;
	parameter MS_PERIOD = HS_PERIOD*2;
	parameter LS_PERIOD = MS_PERIOD*2;
	parameter CLK_PERIOD = 4; // Clock period in ns (250 MHz)
	parameter SCK_CYC = 100;
    parameter SCK_PERIOD = CLK_PERIOD*SCK_CYC; // SCK period in clock periods
	
	localparam DSP_CONV_STAT_CONV_DONE = 16'h2000; // 1 << 13
	localparam DSP_CONV_STAT_POINT_CNT_MASK = 16'h1FFF;

// Inputs
    reg hs_clk;
    reg ms_clk;
	reg adc_conv_clk;
    reg lock;
    reg clk;
    reg rst;
    reg sck;
    reg ncs;
    reg si;
	reg [11:0] adc_a = 0;
	reg [11:0] adc_b = 0;

	reg conv_start = 0;

// Outputs
    wire so;
    wire meas_done;
    wire adc_clk;

// Bidirs


// Instantiate the UUT
// Please check and add your parameters manually
    dsp_core #(
		.meas_points(4)
	) UUT (
		.hs_clk(hs_clk),
		.ms_clk(ms_clk),
		.pll_lock(lock),
        .sys_clk(clk), 
        .rst(rst), 
        .sck(sck & conv_start), 
        .ncs(ncs), 
        .so(so), 
        .si(si), 
        .meas_done(meas_done), 
        .adc_clk(adc_clk),
		.adc_conv_clk(adc_conv_clk),
		.adc_a(adc_a),
		.adc_b(adc_b)
    );

	// Clock generation
    initial begin
        clk = 0;
		#(PRE_ST_DELAY)
		#(0.5)
        forever #(CLK_PERIOD / 2) clk = ~clk; // Toggle clock every half period
    end
	
    initial begin
        hs_clk = 0;
		#(PRE_ST_DELAY)
		#(0.5)
        forever #(HS_PERIOD / 2) hs_clk = ~hs_clk; // Toggle clock every half period
    end
	
    initial begin
        ms_clk = 0;
		#(0.5)
		#(PRE_ST_DELAY)
        forever #(MS_PERIOD / 2) ms_clk = ~ms_clk; // Toggle clock every half period
    end
	
    initial begin
        adc_conv_clk = 0;
		#(0.5)
		#(PRE_ST_DELAY)
		#(ADC_DELAY)
        forever #(LS_PERIOD / 2) begin
			adc_conv_clk = ~adc_conv_clk; // Toggle clock every half period
			if (~adc_conv_clk) begin
				adc_a = adc_a + 1;
				adc_b = adc_b + 1;
			end
		end
    end
	
	// SCK generation
    initial begin
        sck = 0;
		#(PRE_ST_DELAY)
		#(PLL_LOCK_DELAY)
        forever #(SCK_PERIOD / 2) sck = ~sck; // Toggle sck every half period
    end

// Initialize Inputs
// You can add your stimulus here

// Task to send address and data (similar to send_DSP in C)
task send_DSP;
    input [6:0] addr;    // 7-bit address
    input [23:0] data;   // 24-bit data
    integer i, j;
    begin
        // Activate chip select
        ncs = 0;

        // Send address (including the read/write bit)
		conv_start = 1;
        si = 0; // Read bit (0 for write command)
        #SCK_PERIOD;

        // Loop through the 7 address bits (MSB first)
        for (i = 6; i >= 0; i = i - 1) begin
            si = addr[i];  // Set `si` to the corresponding bit of the address
            #SCK_PERIOD;   // Wait for a clock period for each bit
        end

        // Send 24-bit data
        for (j = 23; j >= 0; j = j - 1) begin
            si = data[j];  // Set `si` to the corresponding bit of the data
            #SCK_PERIOD;   // Wait for a clock period for each bit
        end
		
		conv_start = 0;

        // Deactivate chip select
        #(SCK_PERIOD);
        ncs = 1;
		
		// Wait a bit
        #(10*SCK_PERIOD);
    end
endtask

// Task to read from DSP (similar to read_DSP in C)
task read_DSP;
    input [6:0] addr;    // 7-bit address
    output [23:0] data;  // 24-bit data (output)
    integer i, j;
    begin
        // Activate chip select
        ncs = 0;

        // Send address (read command and 7-bit address)
		conv_start = 1;
        si = 1; // Read bit
        #SCK_PERIOD;

        // Loop through the 7 address bits (MSB first)
        for (i = 6; i >= 0; i = i - 1) begin
            si = addr[i];  // Set `si` to the corresponding bit of the address
            #SCK_PERIOD;   // Wait for a clock period for each bit
        end
		
        si = 0; // Read bit

        // Receive 24-bit data (assuming data is coming on `si`)
        for (j = 23; j >= 0; j = j - 1) begin
            #(SCK_PERIOD/2);	// Wait to latch data
            data[j] = so;		// Capture the data from SPI output
            #(SCK_PERIOD/2);
        end
		conv_start = 0;

        // Deactivate chip select
        #(SCK_PERIOD);
        ncs = 1;
		
		// Wait a bit
        #(10*SCK_PERIOD);
    end
endtask

// Task to monitor DSP conversion
task monitor_dsp_conversion;
    input integer max_wait_cycles;
    output conversion_success;
    output [12:0] final_point_count;

    reg [23:0] rx_data;
    reg [12:0] point_count;
    integer wait_cycles;

    begin
        conversion_success = 0; // Initialize output (0 = not done)

        for (wait_cycles = 0; wait_cycles < max_wait_cycles; wait_cycles = wait_cycles + 1) begin
            // Read DSP status
            read_DSP(7'b0000011, rx_data);
            
            // Extract point count
            point_count = rx_data & DSP_CONV_STAT_POINT_CNT_MASK;
            
            // Check if conversion is done
            if (rx_data & DSP_CONV_STAT_CONV_DONE) begin
                conversion_success = 1; // Set output (1 = done)
                final_point_count = point_count;
                $display("Conversion done. Final point count: %d", point_count);
                disable monitor_dsp_conversion;
            end
            
            if ((wait_cycles % 10) == 0) begin // Display every 10 cycles
                $display("Waiting for conversion. Current point count: %d", point_count);
            end
            
            #SCK_PERIOD;
        end

        $display("Timeout: Conversion did not complete within %d cycles.", max_wait_cycles);
        final_point_count = point_count; // Return the last observed point count
        conversion_success = 0; // Conversion not complete (timeout)
    end
endtask

reg [23:0] rx_data;

reg [12:0] final_count;
reg conversion_success;

initial begin
    rst = 0; // No reset signal (like we have irl)
    lock = 0;
    #(PRE_ST_DELAY) // Before the PLL locks
    ncs = 1; // Chip not selected at the beginning
    si = 0;
    #(PLL_LOCK_DELAY)
    lock = 1;

    forever begin
        #(2 * SCK_PERIOD);
        rst = 0;
		
		// Start the conversion
		send_DSP(7'b0000000, 24'h000000);

		// Read some
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);
		read_DSP(7'b0000000, rx_data);

        // Trigger reset after some cycles
        #(2*SCK_PERIOD);
        rst = 1;
    end
end

endmodule // dsp_core_tf