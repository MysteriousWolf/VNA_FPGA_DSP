
/*******************************************************************************
    Verilog netlist generated by IPGEN Lattice Radiant Software (64-bit)
    2023.2.1.288.0
    Soft IP Version: 2.0.0
    2024 10 01 10:43:57
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
module fir_shift_reg (clk_i, 
        rst_i, 
        clk_en_i, 
        wr_data_i, 
        rd_data_o) ;
    input clk_i ; 
    input rst_i ; 
    input clk_en_i ; 
    input [11:0] wr_data_i ; 
    output [11:0] rd_data_o ; 
    fir_shift_reg_ipgen_lscc_shift_register #(.FAMILY("iCE40UP"),
            .MAX_SHIFT(16),
            .DATA_WIDTH(12),
            .MAX_WIDTH(5),
            .REGMODE("reg"),
            .SHIFT_REG_TYPE("fixed"),
            .IMPLEMENTATION("EBR")) lscc_shift_register_inst (.clk_i(clk_i), 
                .rst_i(rst_i), 
                .clk_en_i(clk_en_i), 
                .wr_data_i(wr_data_i[11:0]), 
                .addr_i(5'b11111), 
                .rd_data_o(rd_data_o[11:0])) ; 
endmodule



// =============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// -----------------------------------------------------------------------------
//   Copyright (c) 2023 by Lattice Semiconductor Corporation
//   ALL RIGHTS RESERVED
// -----------------------------------------------------------------------------
//
//   Permission:
//
//      Lattice SG Pte. Ltd. grants permission to use this code
//      pursuant to the terms of the Lattice Reference Design License Agreement.
//
//
//   Disclaimer:
//
//      This VHDL or Verilog source code is intended as a design reference
//      which illustrates how these types of functions can be implemented.
//      It is the user's responsibility to verify their design for
//      consistency and functionality through the use of formal
//      verification methods.  Lattice provides no warranty
//      regarding the use or functionality of this code.
//
// -----------------------------------------------------------------------------
//
//                  Lattice SG Pte. Ltd.
//                  101 Thomson Road, United Square #07-02
//                  Singapore 307591
//
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                       +65-6631-2000 (Singapore)
//                       +1-503-268-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// -----------------------------------------------------------------------------
//
// =============================================================================
//                         FILE DETAILS
// Project               : Radiant Software 1.1
// File                  : lscc_shift_register.v
// Title                 :
// Dependencies          : 
// Description           : Instantiates a shift register.
// =============================================================================
//                        REVISION HISTORY
// Version               : 1.0.0.
// Author(s)             :
// Mod. Date             :
// Changes Made          : Initial release.
// =============================================================================
module fir_shift_reg_ipgen_lscc_shift_register #(parameter DATA_WIDTH = 8, 
        parameter REGMODE = "reg", 
        parameter SHIFT_REG_TYPE = "fixed", 
        parameter MAX_SHIFT = 16, 
        parameter MAX_WIDTH = clog2((MAX_SHIFT + 1)), 
        parameter IMPLEMENTATION = "EBR", 
        parameter FAMILY = "common") (
    //----------------------------
    // Inputs
    //----------------------------
    input clk_i, 
    input rst_i, 
    input clk_en_i, 
    input [(DATA_WIDTH - 1):0] wr_data_i, 
    input [(MAX_WIDTH - 1):0] addr_i, 
    //----------------------------
    // Outputs
    //----------------------------
    output [(DATA_WIDTH - 1):0] rd_data_o) ;
    //--end_ports--
    localparam SHIFT_USE = (MAX_SHIFT - 1) ; 
    generate
        reg [(MAX_WIDTH - 1):0] wr_addr_r ; 
        reg [(MAX_WIDTH - 1):0] rd_addr_r ; 
        reg [(MAX_WIDTH - 1):0] wr_addr_nxt_r ; 
        reg [(MAX_WIDTH - 1):0] rd_addr_nxt_r ; 
        reg [(MAX_WIDTH - 1):0] rd_addr_p_r ; 
        if ((SHIFT_REG_TYPE == "fixed")) 
            begin : fixed
                always
                    @(*)
                    begin
                        wr_addr_nxt_r = wr_addr_r ;
                        rd_addr_r = rd_addr_p_r ;
                        if ((clk_en_i == 1'b1)) 
                            begin
                                wr_addr_nxt_r = ((wr_addr_r == MAX_SHIFT) ? {MAX_WIDTH{1'b0}} : (wr_addr_r + 1'b1)) ;
                                rd_addr_r = wr_addr_nxt_r ;
                            end
                    end
            end
        else
            if ((SHIFT_REG_TYPE == "variable")) 
                begin : variable
                    localparam MX_SIZE_VAR = (2 ** MAX_WIDTH) ; 
                    always
                        @(*)
                        begin
                            wr_addr_nxt_r = wr_addr_r ;
                            rd_addr_r = rd_addr_p_r ;
                            if ((clk_en_i == 1'b1)) 
                                begin
                                    wr_addr_nxt_r = (wr_addr_r + 1) ;
                                    rd_addr_r = ((wr_addr_r - addr_i) - 1'b1) ;
                                end
                        end
                end
        always
            @(posedge clk_i or 
                posedge rst_i)
            begin
                if ((rst_i == 1'b1)) 
                    begin
                        wr_addr_r <=  {MAX_WIDTH{1'b0}} ;
                        rd_addr_p_r <=  {MAX_WIDTH{1'b0}} ;
                    end
                else
                    begin
                        wr_addr_r <=  wr_addr_nxt_r ;
                        rd_addr_p_r <=  rd_addr_r ;
                    end
            end
        if ((IMPLEMENTATION == "EBR")) 
            begin : mem_EBR
                (* syn_ramstyle="block_ram" *) reg [(DATA_WIDTH - 1):0] mem [((2 ** MAX_WIDTH) - 1):0] ; 
                reg [(DATA_WIDTH - 1):0] data_raw_r = {DATA_WIDTH{1'b0}} ; 
                reg [(DATA_WIDTH - 1):0] data_buff_r = {DATA_WIDTH{1'b0}} ; 
                if ((MAX_WIDTH <= 10)) 
                    begin : genblk1
                        integer i0 ; 
                        initial
                            begin
                                for (i0 = 0 ; (i0 < (2 ** MAX_WIDTH)) ; i0 = (i0 + 1))
                                    begin
                                        mem[i0] = {DATA_WIDTH{1'b0}} ;
                                    end
                            end
                    end
                assign rd_data_o = ((REGMODE == "reg") ? data_buff_r : data_raw_r) ; 
                always
                    @(posedge clk_i)
                    begin
                        if ((clk_en_i == 1'b1)) 
                            begin
                                mem[wr_addr_r] <=  wr_data_i ;
                            end
                    end
                always
                    @(posedge clk_i)
                    begin
                        if ((clk_en_i == 1'b1)) 
                            begin
                                data_raw_r <=  mem[rd_addr_r] ;
                            end
                    end
                if ((REGMODE == "reg")) 
                    begin : mem_reg
                        always
                            @(posedge clk_i or 
                                posedge rst_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                    end
                                else
                                    begin
                                        if ((clk_en_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  data_raw_r ;
                                            end
                                    end
                            end
                    end
            end
        else
            begin : mem_LUT
                if (((FAMILY == "iCE40UP") || (FAMILY == "common"))) 
                    begin : mem_noDist
                        (* syn_ramstyle="registers" *) reg [(DATA_WIDTH - 1):0] mem [((2 ** MAX_WIDTH) - 1):0] ; 
                        reg [(DATA_WIDTH - 1):0] data_raw_r = {DATA_WIDTH{1'b0}} ; 
                        reg [(DATA_WIDTH - 1):0] data_buff_r = {DATA_WIDTH{1'b0}} ; 
                        assign rd_data_o = ((REGMODE == "reg") ? data_buff_r : data_raw_r) ; 
                        if ((MAX_WIDTH <= 10)) 
                            begin : genblk1
                                integer i0 ; 
                                initial
                                    begin
                                        for (i0 = 0 ; (i0 < (2 ** MAX_WIDTH)) ; i0 = (i0 + 1))
                                            begin
                                                mem[i0] = {DATA_WIDTH{1'b0}} ;
                                            end
                                    end
                            end
                        always
                            @(posedge clk_i)
                            begin
                                if ((clk_en_i == 1'b1)) 
                                    begin
                                        mem[wr_addr_r] <=  wr_data_i ;
                                    end
                            end
                        always
                            @(posedge clk_i)
                            begin
                                if ((clk_en_i == 1'b1)) 
                                    begin
                                        data_raw_r <=  mem[rd_addr_r] ;
                                    end
                            end
                        if ((REGMODE == "reg")) 
                            begin : mem_reg
                                always
                                    @(posedge clk_i or 
                                        posedge rst_i)
                                    begin
                                        if ((rst_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                            end
                                        else
                                            begin
                                                if ((clk_en_i == 1'b1)) 
                                                    begin
                                                        data_buff_r <=  data_raw_r ;
                                                    end
                                            end
                                    end
                            end
                    end
                else
                    begin : mem_lifcl
                        (* syn_ramstyle="distributed" *) reg [(DATA_WIDTH - 1):0] mem [((2 ** MAX_WIDTH) - 1):0] ; 
                        reg [(DATA_WIDTH - 1):0] data_raw_r = {DATA_WIDTH{1'b0}} ; 
                        reg [(DATA_WIDTH - 1):0] data_buff_r = {DATA_WIDTH{1'b0}} ; 
                        assign rd_data_o = ((REGMODE == "reg") ? data_buff_r : data_raw_r) ; 
                        if ((MAX_WIDTH <= 10)) 
                            begin : genblk1
                                integer i0 ; 
                                initial
                                    begin
                                        for (i0 = 0 ; (i0 < (2 ** MAX_WIDTH)) ; i0 = (i0 + 1))
                                            begin
                                                mem[i0] = {DATA_WIDTH{1'b0}} ;
                                            end
                                    end
                            end
                        always
                            @(posedge clk_i)
                            begin
                                if ((clk_en_i == 1'b1)) 
                                    begin
                                        mem[wr_addr_r] <=  wr_data_i ;
                                    end
                            end
                        always
                            @(*)
                            begin
                                data_raw_r = mem[rd_addr_r] ;
                            end
                        if ((REGMODE == "reg")) 
                            begin : mem_reg
                                always
                                    @(posedge clk_i or 
                                        posedge rst_i)
                                    begin
                                        if ((rst_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                            end
                                        else
                                            begin
                                                if ((clk_en_i == 1'b1)) 
                                                    begin
                                                        data_buff_r <=  data_raw_r ;
                                                    end
                                            end
                                    end
                            end
                    end
            end
    endgenerate
    //------------------------------------------------------------------------------
    // Function Definition
    //------------------------------------------------------------------------------
    function [31:0] clog2 ; 
        input [31:0] value ; 
        reg [31:0] num ; 
        begin
            num = (value - 1) ;
            for (clog2 = 0 ; (num > 0) ; clog2 = (clog2 + 1))
                num = (num >> 1) ;
        end
    endfunction
endmodule


