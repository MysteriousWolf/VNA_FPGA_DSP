

// TOOL:     vlog2tf
// DATE:     Tue Oct  8 14:04:33 2024
 
// TITLE:    Lattice Semiconductor Corporation
// MODULE:   dsp_core
// DESIGN:   dsp_core
// FILENAME: VNA_FPGA_DSP_tf.v
// PROJECT:  VNA_FPGA_DSP
// VERSION:  2.0
// This file is auto generated by Radiant


`timescale 1 ns / 1 ps

/*module pll_core (
    input ref_clk_i,        // Reference clock input (ignored for this test)
    input rst_n_i,          // Reset signal, active low
    output reg outcore_o,   // Configurable frequency clock output
    output reg outglobal_o, // Global version of the clock output (mirrors outcore_o)
    output reg outcoreb_o,  // Half frequency clock output
    output reg outglobalb_o // Global version of the half frequency output (mirrors outcoreb_o)
);

    // Configurable clock frequency parameters (in MHz)
    parameter FREQ_CORE = 250;       // Frequency for outcore_o (default 250 MHz)
    parameter FREQ_COREB = 125;      // Frequency for outcoreb_o (default 125 MHz)
    
    // Convert frequencies to time period in nanoseconds
    localparam real PERIOD_CORE_NS = 1000.0 / FREQ_CORE;       // Period for outcore_o in ns
    localparam real HALF_PERIOD_CORE_NS = PERIOD_CORE_NS / 2;  // Half-period for outcore_o in ns
    localparam real PERIOD_COREB_NS = 1000.0 / FREQ_COREB;     // Period for outcoreb_o in ns
    localparam real HALF_PERIOD_COREB_NS = PERIOD_COREB_NS / 2; // Half-period for outcoreb_o in ns

    // Clock generation for outcore_o and outglobal_o (250 MHz)
    initial begin
		outcore_o = 0;
		outglobal_o = 0;
		forever begin
			if (rst_n_i == 0) begin
				outcore_o = 0;
				outglobal_o = 0;
				#(PERIOD_CORE_NS);  // Wait for one full clock period after reset
			end else begin
				outcore_o = ~outcore_o;      // Toggle outcore_o
				outglobal_o = outcore_o;     // Global mirrors outcore_o
				#(HALF_PERIOD_CORE_NS);      // Wait for half a clock period
			end
		end
    end

    // Clock generation for outcoreb_o and outglobalb_o (125 MHz)
    initial begin
		outcoreb_o = 0;
		outglobalb_o = 0;
		forever begin
			if (rst_n_i == 0) begin
				outcoreb_o = 0;
				outglobalb_o = 0;
				#(PERIOD_COREB_NS);  // Wait for one full clock period after reset
			end else begin
				outcoreb_o = ~outcoreb_o;    // Toggle outcoreb_o
				outglobalb_o = outcoreb_o;   // Global mirrors outcoreb_o
				#(HALF_PERIOD_COREB_NS);     // Wait for half a clock period
			end
		end
    end
endmodule*/

// Define Module for Test Fixture
module dsp_core_tf();
	
	// Parameters
	parameter PRE_ST_DELAY = 10;
	parameter PLL_LOCK_DELAY = 10;
	parameter HS_PERIOD = 1000/250;
	parameter MS_PERIOD = 1000/125;
	parameter CLK_PERIOD = 4; // Clock period in ns (250 MHz)
	parameter SCK_CYC = 50;
    parameter SCK_PERIOD = CLK_PERIOD*SCK_CYC; // SCK period in clock periods

// Inputs
    reg hs_clk;
    reg ms_clk;
    reg lock;
    reg clk;
    reg rst;
    reg sck;
    reg ncs;
    reg si;


// Outputs
    wire so;
    wire meas_done;
    wire adc_clk;

// Bidirs


// Instantiate the UUT
// Please check and add your parameters manually
    dsp_core UUT (
		.hs_clk(hs_clk),
		.ms_clk(ms_clk),
		.pll_lock(lock),
        .sys_clk(clk), 
        .rst(rst), 
        .sck(sck), 
        .ncs(ncs), 
        .so(so), 
        .si(si), 
        .meas_done(meas_done), 
        .adc_clk(adc_clk)
    );

	// Clock generation
    initial begin
        clk = 0;
		#(PRE_ST_DELAY)
		#(0.5)
        forever #(CLK_PERIOD / 2) clk = ~clk; // Toggle clock every half period
    end
	
    initial begin
        hs_clk = 0;
		#(PRE_ST_DELAY)
		#(0.5)
        forever #(HS_PERIOD / 2) hs_clk = ~hs_clk; // Toggle clock every half period
    end
	
    initial begin
        ms_clk = 0;
		#(0.5)
		#(PRE_ST_DELAY)
        forever #(MS_PERIOD / 2) ms_clk = ~ms_clk; // Toggle clock every half period
    end
	
	// SCK generation
    initial begin
        sck = 0;
		#(PRE_ST_DELAY)
		#(PLL_LOCK_DELAY)
        forever #(SCK_PERIOD / 2) sck = ~sck; // Toggle sck every half period
    end


// Initialize Inputs
// You can add your stimulus here
initial begin
	// Simulate a moment of the undefined state of FPGA
    rst = 0; // No reset signal (like we have irl)
	lock = 0;
	#(PRE_ST_DELAY) // Before the PLL locks
    ncs = 1; // Chip not selected at the beginning
    si = 0;
	#(PLL_LOCK_DELAY)
	lock = 1;

    forever begin
        // Release reset after some cycles
        #(2 * SCK_PERIOD); 
        rst = 0;
        
        // First packet
        #(SCK_PERIOD); // Data changes on clock falling edges
        ncs = 0;

        // Send read command (1 bit read, 7 bits address: 0b1111111)
        si = 1; // Read bit
        #SCK_PERIOD;
        si = 1; // Address bit 6
        #SCK_PERIOD;
        si = 1; // Address bit 5
        #SCK_PERIOD;
        si = 1; // Address bit 4
        #SCK_PERIOD;
        si = 1; // Address bit 3
        #SCK_PERIOD;
        si = 1; // Address bit 2
        #SCK_PERIOD;
        si = 1; // Address bit 1
        #SCK_PERIOD;
        si = 1; // Address bit 0
        #SCK_PERIOD;

        // Send 24-bit data: 0xFA9C34 (11111010 10011100 00110100)
        si = 1; // MSB of data (bit 23)
        #SCK_PERIOD;
        si = 1; // bit 22
        #SCK_PERIOD;
        si = 1; // bit 21
        #SCK_PERIOD;
        si = 1; // bit 20
        #SCK_PERIOD;
        si = 1; // bit 19
        #SCK_PERIOD;
        si = 0; // bit 18
        #SCK_PERIOD;
        si = 1; // bit 17
        #SCK_PERIOD;
        si = 0; // bit 16
        #SCK_PERIOD;
        si = 1; // bit 15
        #SCK_PERIOD;
        si = 0; // bit 14
        #SCK_PERIOD;
        si = 0; // bit 13
        #SCK_PERIOD;
        si = 1; // bit 12
        #SCK_PERIOD;
        si = 1; // bit 11
        #SCK_PERIOD;
        si = 1; // bit 10
        #SCK_PERIOD;
        si = 0; // bit 9
        #SCK_PERIOD;
        si = 0; // bit 8
        #SCK_PERIOD;
        si = 0; // bit 7
        #SCK_PERIOD;
        si = 0; // bit 6
        #SCK_PERIOD;
        si = 1; // bit 5
        #SCK_PERIOD;
        si = 1; // bit 4
        #SCK_PERIOD;
        si = 0; // bit 3
        #SCK_PERIOD;
        si = 1; // bit 2
        #SCK_PERIOD;
        si = 0; // bit 1
        #SCK_PERIOD;
        si = 0; // bit 0 (LSB)
        #SCK_PERIOD;

        // Second packet (addr = 0b1100110, data = 0xFA9C34)

        // Send read command (1 bit read, 7 bits address: 0b1100110)
        si = 1; // Read bit
        #SCK_PERIOD;
        si = 1; // Address bit 6
        #SCK_PERIOD;
        si = 1; // Address bit 5
        #SCK_PERIOD;
        si = 0; // Address bit 4
        #SCK_PERIOD;
        si = 0; // Address bit 3
        #SCK_PERIOD;
        si = 1; // Address bit 2
        #SCK_PERIOD;
        si = 1; // Address bit 1
        #SCK_PERIOD;
        si = 0; // Address bit 0
        #SCK_PERIOD;

        // Send 24-bit data: 0xFA9C34 (11111010 10011100 00110100)
        si = 1; // MSB of data (bit 23)
        #SCK_PERIOD;
        si = 1; // bit 22
        #SCK_PERIOD;
        si = 1; // bit 21
        #SCK_PERIOD;
        si = 1; // bit 20
        #SCK_PERIOD;
        si = 1; // bit 19
        #SCK_PERIOD;
        si = 0; // bit 18
        #SCK_PERIOD;
        si = 1; // bit 17
        #SCK_PERIOD;
        si = 0; // bit 16
        #SCK_PERIOD;
        si = 1; // bit 15
        #SCK_PERIOD;
        si = 0; // bit 14
        #SCK_PERIOD;
        si = 0; // bit 13
        #SCK_PERIOD;
        si = 1; // bit 12
        #SCK_PERIOD;
        si = 1; // bit 11
        #SCK_PERIOD;
        si = 1; // bit 10
        #SCK_PERIOD;
        si = 0; // bit 9
        #SCK_PERIOD;
        si = 0; // bit 8
        #SCK_PERIOD;
        si = 0; // bit 7
        #SCK_PERIOD;
        si = 0; // bit 6
        #SCK_PERIOD;
        si = 1; // bit 5
        #SCK_PERIOD;
        si = 1; // bit 4
        #SCK_PERIOD;
        si = 0; // bit 3
        #SCK_PERIOD;
        si = 1; // bit 2
        #SCK_PERIOD;
        si = 0; // bit 1
        #SCK_PERIOD;
        si = 0; // bit 0 (LSB)
        #SCK_PERIOD;

        #(SCK_PERIOD / 2);
        ncs = 1;

        // Trigger reset after some cycles
        #(10 * CLK_PERIOD); 
        rst = 1;
    end
end


endmodule // dsp_core_tf